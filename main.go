package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"slices"
	"strings"

	"github.com/hashicorp/hcl/v2"
	"github.com/hashicorp/hcl/v2/hclsyntax"
	"github.com/magiconair/properties"
)

type HCLBlock struct {
	Type       string
	Labels     []string
	Attributes map[string]string
	Blocks     []*HCLBlock
}

var (
	inputFilePath string
	outPath       string
	pathSeparator string

	migrateMode    bool
	migrateInDir   string
	migrateOutFile string

	langs       []string = make([]string, 0)
	defaultLang string
)

func main() {
	flag.StringVar(&inputFilePath, "i", "i18n.hcl", "Specify input file")
	flag.StringVar(&outPath, "o", "./out", "Specify output directory")
	flag.StringVar(&pathSeparator, "s", ".", "Specify path separator for generated file")
	flag.BoolVar(&migrateMode, "migrate", false, "Translate a directory of i18n .properties files to a polyglot .hcl file")
	flag.StringVar(&migrateInDir, "m-in", ".", "Migration: input directory")
	flag.StringVar(&migrateOutFile, "m-out", "i18n.hcl", "Migration: output file")

	flag.Parse()

	if migrateMode {
		migrateProperties()
	} else {
		generateProperties()
	}
}

func generateProperties() {
	content, err := os.ReadFile(inputFilePath)
	if err != nil {
		panic(err)
	}

	file, diag := hclsyntax.ParseConfig(content, inputFilePath, hcl.Pos{Line: 1, Column: 1})
	if file == nil {
		panic(fmt.Sprintln("Could not parse input file", inputFilePath))
	}

	if diag.HasErrors() {
		fmt.Println(diag.Error())
		return
	}

	searchConfig(file.Body)
	blocks := traverseBlocks(file.Body, "")
	err = os.MkdirAll(outPath, os.ModePerm)
	if err != nil {
		panic(err.Error())
	}
	for _, lang := range langs {
		filePath := filepath.Join(outPath, "i18n_"+lang+".properties")
		optFile, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
		if err != nil {
			fmt.Printf("[ERROR] Unable to open or create file %s\nMake sure its path exists and that you have sufficient permissions\n", filePath)
			continue
		}
		optFile.WriteString("# This file was auto-generated by polyglot\n")
		for path, trans := range blocks {
			val, ok := trans[lang]
			if !ok {
				fmt.Printf("[ERROR] No translation for language '%s' and 'default' in path '%s'\n", lang, path)
				continue
			}
			optFile.WriteString(path + "=" + val + "\n")
		}
	}
	if defaultLang != "" {
		filePath := filepath.Join(outPath, "i18n.properties")
		optFile, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
		if err != nil {
			fmt.Printf("[ERROR] Unable to open or create file %s\nMake sure its path exists and that you have sufficient permissions\n", filePath)
			return
		}
		optFile.WriteString("# This file was auto-generated by polyglot\n")
		for path, trans := range blocks {
			val, ok := trans[defaultLang]
			if !ok {
				fmt.Printf("[ERROR] No translation for default language '%s' in path '%s'\n", defaultLang, filePath)
				continue
			}
			optFile.WriteString(path + "=" + val + "\n")
		}
	}
	fmt.Println("Successfully created i18n files")
}

// Search the declared languages and default language
// These must be declared on top level (not in a nested block)
// Example:
// langs = [en, nl]
// default = en
func searchConfig(body hcl.Body) {
	var foundLangs bool
	var foundDefault bool
	syntaxBody, ok := body.(*hclsyntax.Body)
	if !ok {
		return //Error handling? Unexpected body type
	}
	for _, attr := range syntaxBody.Attributes {
		if attr.Name == "langs" {
			expr, ok := attr.Expr.(*hclsyntax.TupleConsExpr)
			if !ok {
				panic("[ERROR] Expected tuple for array langs")
			}
			if len(expr.Exprs) == 0 {
				panic("[ERROR] Empty languages declaration")
			}
			for _, elem := range expr.Exprs {
				val, _ := elem.Value(nil)
				langs = append(langs, val.AsString())
			}
			foundLangs = true
		} else if attr.Name == "default" {
			val, diags := attr.Expr.Value(nil)
			if diags.HasErrors() {
				panic("[ERROR] Failed to evaluate default lang declaration")
			}
			defaultLang = val.AsString()
			foundDefault = true
		}
	}
	if !foundLangs {
		panic("[ERROR] No languages declaration found. Please specify the used languages like this:\nlangs = [en, nl]")
	}
	if !foundDefault {
		fmt.Println("[WARNING] No default language specified, defaulting to 'default'")
		defaultLang = "default"
	} else if !slices.Contains(langs, defaultLang) {
		panic(fmt.Sprintf("[ERROR] The default language '%s' is not contained in the languages declaration (%+v)", defaultLang, langs))
	}
}

func traverseBlocks(body hcl.Body, path string) map[string]map[string]string {
	// Type assertion to access blocks and attributes directly
	syntaxBody, ok := body.(*hclsyntax.Body)
	if !ok {
		fmt.Println("[ERROR] Error asserting body type")
		return nil
	}

	var pathMember string
	if path != "" {
		pathMember = path + pathSeparator
	} else {
		pathMember = path
	}
	blockMap := make(map[string]map[string]string, len(syntaxBody.Blocks))
	var err error //to avoid shadowing from := opertator
	// Iterate over blocks
	for _, block := range syntaxBody.Blocks {
		blockName := block.Type
		if len(block.Labels) > 0 {
			for _, label := range block.Labels {
				blockName += pathSeparator + label
			}
		}
		blockMap, err = mergeMaps(traverseBlocks(block.Body, pathMember+blockName), blockMap)
		if err != nil {
			fmt.Println("[ERROR] " + err.Error())
		}
	}

	if path != "" && len(syntaxBody.Attributes) > 0 {
		translations := make(map[string]string, len(langs))
		for attrName, attr := range syntaxBody.Attributes {
			val, diags := attr.Expr.Value(nil) // Using a nil context; customize as needed
			if diags.HasErrors() {
				fmt.Println("[ERROR] Error evaluating value for", attrName, diags.Error())
				continue //?
			}
			if !slices.Contains(langs, attrName) && attrName != "default" {
				fmt.Printf("[WARNING] Unknown attribute '%s' in path '%s'\n", attrName, path)
				continue
			}
			translations[attrName] = val.AsString()
		}
		blockMap[path] = translations
	}
	return blockMap
}

func mergeMaps[T comparable, E any](m1, m2 map[T]E) (map[T]E, error) {
	for k, v := range m2 {
		if _, ok := m1[k]; ok {
			return nil, fmt.Errorf("key %+v is contained in both maps", k)
		}
		m1[k] = v
	}
	return m1, nil
}

func migrateProperties() {
	files, err := os.ReadDir(migrateInDir)
	if err != nil {
		panic(fmt.Sprintf("[ERROR] Cannot open directory %s, %s", migrateInDir, err))
	}
	fileNameRegex := regexp.MustCompile(`i18n_.*\.properties`)
	blocks := make(map[string]*HCLBlock)
	var haveDefaultLang bool
	for _, file := range files {
		if (file.Name() == "i18n.properties" || fileNameRegex.Match([]byte(file.Name()))) && !file.IsDir() {
			filePath := filepath.Join(migrateInDir, file.Name())
			var lang string
			if file.Name() == "i18n.properties" {
				lang = "default"
				haveDefaultLang = true
			} else {
				lang = strings.Split(strings.Split(file.Name(), "i18n_")[1], ".properties")[0] //Get the language name from the file name (thanks SAP)
				langs = append(langs, lang)
			}
			p := properties.MustLoadFile(filePath, properties.UTF8)
			m := p.Map()
			for path, value := range m {
				pathMembers := strings.Split(path, pathSeparator)
				b, ok := blocks[path]
				if !ok {
					b = &HCLBlock{Type: pathMembers[len(pathMembers)-1]}
					blocks[path] = b
				}
				if b.Attributes == nil {
					b.Attributes = make(map[string]string)
				}
				b.Attributes[lang] = value
				if len(pathMembers) > 1 {
					findOrCreateParents(b, pathMembers[:len(pathMembers)-1], &blocks)
				}
			}
		}
	}
	//Remove unnecessary "default" entries
	if haveDefaultLang {
		for _, block := range blocks {
			if block.Attributes != nil && len(block.Attributes) == len(langs)+1 {
				for lang, trans := range block.Attributes {
					//All langs are defined and the "default" entry equals at least one other
					//If it doesn't equal another entry, we assume the default string has its place and keep it
					if lang != "default" {
						if trans == block.Attributes["default"] {
							delete(block.Attributes, "default")
						}
					}
				}
			}
		}
	}
	//Flatten empty blocks to labels of its parent
	//Also, get all top level blocks
	topLevelBlocks := make([]*HCLBlock, 0)
	for path, block := range blocks {
		pathMembers := strings.Split(path, pathSeparator)
		if len(pathMembers) == 1 {
			topLevelBlocks = append(topLevelBlocks, block)
		}
		if len(pathMembers) > 1 {
			//Get parent block
			parentPath := strings.Join(pathMembers[:len(pathMembers)-1], pathSeparator)
			parentBlock, ok := blocks[parentPath]
			if !ok {
				fmt.Printf("[FAULT] Parent block %s of block %s not found during label conversion", parentPath, path)
				continue
			}
			//Is it the parent's only child?
			//Also, does the parent have its own attributes?
			if len(parentBlock.Blocks) == 1 && len(parentBlock.Attributes) == 0 {
				//Add current block as a label
				parentBlock.Labels = append(parentBlock.Labels, pathMembers[len(pathMembers)-1])
				//Add attributes to parent
				parentBlock.Attributes = block.Attributes
				//Give children to parent
				parentBlock.Blocks = block.Blocks
				//Delete from the map and leave it to the GC
				delete(blocks, path)
			}
		}
	}
	langsString := "langs = [\""
	for i, lang := range langs {
		if i == len(langs)-1 {
			langsString += fmt.Sprintf("%s\"]", lang)
		} else {
			langsString += fmt.Sprintf("%s\", \"", lang)
		}
	}
	blockStrings := []string{langsString}
	for _, block := range topLevelBlocks {
		blockStrings = append(blockStrings, serializeHCL(block, 0))
	}
	hclFile := strings.Join(blockStrings, "\n")
	optFile, err := os.OpenFile(migrateOutFile, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		fmt.Printf("[ERROR] Cannot open output file: %s", err)
		return
	}
	_, err = optFile.WriteString(hclFile)
	if err != nil {
		fmt.Printf("[ERROR] Cannot write to output file: %s", err)
	}
	fmt.Println("Successfully migrated the .properties files")
}

// Recursively look up whether the parent exists, if not create it, set the reference to the original block
// If there are path members left repeat with the newly created block (and ofc the updated parameters)
func findOrCreateParents(b *HCLBlock, parentPathMembers []string, blocks *map[string]*HCLBlock) {
	if len(parentPathMembers) < 1 {
		return
	}
	parentPath := strings.Join(parentPathMembers, pathSeparator)
	parentBlock, ok := (*blocks)[parentPath]
	if !ok {
		//Create parent
		parentBlock = &HCLBlock{Type: parentPathMembers[len(parentPathMembers)-1]}
		(*blocks)[parentPath] = parentBlock
	}
	if !slices.Contains(parentBlock.Blocks, b) {
		parentBlock.Blocks = append(parentBlock.Blocks, b)
	}
	findOrCreateParents(parentBlock, parentPathMembers[:len(parentPathMembers)-1], blocks)
}

func serializeHCL(block *HCLBlock, indentLevel int) string {
	var hclBuilder strings.Builder
	indent := strings.Repeat("\t", indentLevel)

	// Start block
	hclBuilder.WriteString(fmt.Sprintf("%s%s ", indent, block.Type))
	for _, label := range block.Labels {
		hclBuilder.WriteString(fmt.Sprintf("\"%s\" ", label))
	}
	hclBuilder.WriteString("{\n")

	// Attributes
	for key, value := range block.Attributes {
		hclBuilder.WriteString(fmt.Sprintf("%s\t%s = \"%v\"\n", indent, key, value))
	}

	// Nested blocks
	for _, nestedBlock := range block.Blocks {
		hclBuilder.WriteString(serializeHCL(nestedBlock, indentLevel+1))
	}

	// End block
	hclBuilder.WriteString(fmt.Sprintf("%s}\n", indent))

	return hclBuilder.String()
}
